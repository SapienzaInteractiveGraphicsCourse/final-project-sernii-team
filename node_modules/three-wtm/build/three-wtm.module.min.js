import{MaterialLoader as e,Texture as t,BufferGeometry as s,BufferAttribute as i,Box3 as r,Sphere as n,MeshStandardMaterial as a,VertexColors as o,LineBasicMaterial as l,PointsMaterial as u,FileLoader as c}from"three";class h{static addMaterial(e,t,s,i,r){let n;t.name=s,i?(e[s]=t,r&&console.info('Material with name "'+s+'" was forcefully overridden.')):(n=e[s],n?n.uuid!=n.uuid&&r&&console.log('Same material name "'+n.name+'" different uuid ['+n.uuid+"|"+t.uuid+"]"):(e[s]=t,r&&console.info('Material with name "'+s+'" was added.')))}static getMaterialsJSON(e){const t={};let s;for(const i in e)s=e[i],"function"==typeof s.toJSON&&(t[i]=s.toJSON());return t}static cloneMaterial(e,t,s){let i;if(t){let r=t.materialNameOrg;r=null!=r?r:"";const n=e[r];n?(i=n.clone(),Object.assign(i,t.materialProperties),h.addMaterial(e,i,t.materialProperties.name,!0)):s&&console.info('Requested material "'+r+'" is not available!')}return i}}class m{static buildThreeConst(){return"const EventDispatcher = THREE.EventDispatcher;\nconst BufferGeometry = THREE.BufferGeometry;\nconst BufferAttribute = THREE.BufferAttribute;\nconst Box3 = THREE.Box3;\nconst Sphere = THREE.Sphere;\nconst Texture = THREE.Texture;\nconst MaterialLoader = THREE.MaterialLoader;\n"}static buildUglifiedThreeMapping(){return m.buildUglifiedNameAssignment((function(){return s}),"BufferGeometry",/_BufferGeometry/,!1)+m.buildUglifiedNameAssignment((function(){return i}),"BufferAttribute",/_BufferAttribute/,!1)+m.buildUglifiedNameAssignment((function(){return r}),"Box3",/_Box3/,!1)+m.buildUglifiedNameAssignment((function(){return n}),"Sphere",/_Sphere/,!1)+m.buildUglifiedNameAssignment((function(){return t}),"Texture",/_Texture/,!1)+m.buildUglifiedNameAssignment((function(){return e}),"MaterialLoader",/_MaterialLoader/,!1)}static buildUglifiedThreeWtmMapping(){return m.buildUglifiedNameAssignment((function(){return f}),"DataTransport",/_DataTransport/,!0)+m.buildUglifiedNameAssignment((function(){return p}),"GeometryTransport",/_GeometryTransport/,!0)+m.buildUglifiedNameAssignment((function(){return g}),"MeshTransport",/_MeshTransport/,!0)+m.buildUglifiedNameAssignment((function(){return d}),"MaterialsTransport",/_MaterialsTransport/,!0)+m.buildUglifiedNameAssignment((function(){return h}),"MaterialUtils",/_MaterialUtils/,!0)}static buildUglifiedNameAssignment(e,t,s,i){let r=e.toString();r=r.replace(s,"").replace(/[\r\n]+/gm,""),r=r.replace(/.*return/,"").replace(/\}/,"").replace(/;/gm,"");const n=r.trim();let a="";if(n!==t){a="const "+(i?t:n)+" = "+(i?n:t)+";\n"}return a}}class f{constructor(e,t){this.main={cmd:void 0!==e?e:"unknown",id:void 0!==t?t:0,type:"DataTransport",progress:0,buffers:{},params:{}},this.transferables=[]}loadData(e){return this.main.cmd=e.cmd,this.main.id=e.id,this.main.type="DataTransport",this.setProgress(e.progress),this.setParams(e.params),e.buffers&&Object.entries(e.buffers).forEach((([e,t])=>{this.main.buffers[e]=t})),this}getCmd(){return this.main.cmd}getId(){return this.main.id}setParams(e){return null!=e&&(this.main.params=e),this}getParams(){return this.main.params}setProgress(e){return this.main.progress=e,this}addBuffer(e,t){return this.main.buffers[e]=t,this}getBuffer(e){return this.main.buffers[e]}package(e){for(let t of Object.values(this.main.buffers))if(null!=t){const s=e?t.slice(0):t;this.transferables.push(s)}return this}getMain(){return this.main}getTransferables(){return this.transferables}postMessage(e){return e.postMessage(this.main,this.transferables),this}}class d extends f{constructor(e,t){super(e,t),this.main.type="MaterialsTransport",this.main.materials={},this.main.multiMaterialNames={},this.main.cloneInstructions=[]}loadData(t){super.loadData(t),this.main.type="MaterialsTransport",Object.assign(this.main,t);const s=new e;return Object.entries(this.main.materials).forEach((([e,t])=>{this.main.materials[e]=s.parse(t)})),this}_cleanMaterial(e){return Object.entries(e).forEach((([s,i])=>{(i instanceof t||null===i)&&(e[s]=void 0)})),e}addBuffer(e,t){return super.addBuffer(e,t),this}setParams(e){return super.setParams(e),this}setMaterials(e){return null!=e&&Object.keys(e).length>0&&(this.main.materials=e),this}getMaterials(){return this.main.materials}cleanMaterials(){let e,t={};for(let s of Object.values(this.main.materials))"function"==typeof s.clone&&(e=s.clone(),t[e.name]=this._cleanMaterial(e));return this.setMaterials(t),this}package(e){return super.package(e),this.main.materials=h.getMaterialsJSON(this.main.materials),this}hasMultiMaterial(){return Object.keys(this.main.multiMaterialNames).length>0}getSingleMaterial(){return Object.keys(this.main.materials).length>0?Object.entries(this.main.materials)[0][1]:null}processMaterialTransport(e,t){for(let s=0;s<this.main.cloneInstructions.length;s++)h.cloneMaterial(e,this.main.cloneInstructions[s],t);let s;if(this.hasMultiMaterial())s=[],Object.entries(this.main.multiMaterialNames).forEach((([t,i])=>{s[t]=e[i]}));else{const t=this.getSingleMaterial();null!==t&&(s=e[t.name],s||(s=t))}return s}}class p extends f{constructor(e,t){super(e,t),this.main.type="GeometryTransport",this.main.geometryType=0,this.main.geometry={},this.main.bufferGeometry=null}loadData(e){return super.loadData(e),this.main.type="GeometryTransport",this.setGeometry(e.geometry,e.geometryType)}getGeometryType(){return this.main.geometryType}setParams(e){return super.setParams(e),this}setGeometry(e,t){return this.main.geometry=e,this.main.geometryType=t,e instanceof s&&(this.main.bufferGeometry=e),this}package(e){super.package(e);const t=this.main.geometry.getAttribute("position"),s=this.main.geometry.getAttribute("normal"),i=this.main.geometry.getAttribute("uv"),r=this.main.geometry.getAttribute("color"),n=this.main.geometry.getAttribute("skinIndex"),a=this.main.geometry.getAttribute("skinWeight"),o=this.main.geometry.getIndex();return this._addBufferAttributeToTransferable(t,e),this._addBufferAttributeToTransferable(s,e),this._addBufferAttributeToTransferable(i,e),this._addBufferAttributeToTransferable(r,e),this._addBufferAttributeToTransferable(n,e),this._addBufferAttributeToTransferable(a,e),this._addBufferAttributeToTransferable(o,e),this}reconstruct(e){if(this.main.bufferGeometry instanceof s)return this;this.main.bufferGeometry=new s;const t=this.main.geometry;this._assignAttribute(t.attributes.position,"position",e),this._assignAttribute(t.attributes.normal,"normal",e),this._assignAttribute(t.attributes.uv,"uv",e),this._assignAttribute(t.attributes.color,"color",e),this._assignAttribute(t.attributes.skinIndex,"skinIndex",e),this._assignAttribute(t.attributes.skinWeight,"skinWeight",e);const a=t.index;if(null!=a){const t=e?a.array.slice(0):a.array;this.main.bufferGeometry.setIndex(new i(t,a.itemSize,a.normalized))}const o=t.boundingBox;null!==o&&(this.main.bufferGeometry.boundingBox=Object.assign(new r,o));const l=t.boundingSphere;return null!==l&&(this.main.bufferGeometry.boundingSphere=Object.assign(new n,l)),this.main.bufferGeometry.uuid=t.uuid,this.main.bufferGeometry.name=t.name,this.main.bufferGeometry.type=t.type,this.main.bufferGeometry.groups=t.groups,this.main.bufferGeometry.drawRange=t.drawRange,this.main.bufferGeometry.userData=t.userData,this}getBufferGeometry(){return this.main.bufferGeometry}_addBufferAttributeToTransferable(e,t){if(null!=e){const s=t?e.array.slice(0):e.array;this.transferables.push(s.buffer)}return this}_assignAttribute(e,t,s){if(e){const r=s?e.array.slice(0):e.array;this.main.bufferGeometry.setAttribute(t,new i(r,e.itemSize,e.normalized))}return this}}class g extends p{constructor(e,t){super(e,t),this.main.type="MeshTransport",this.main.materialsTransport=new d}loadData(e){return super.loadData(e),this.main.type="MeshTransport",this.main.meshName=e.meshName,this.main.materialsTransport=(new d).loadData(e.materialsTransport.main),this}setParams(e){return super.setParams(e),this}setMaterialsTransport(e){return e instanceof d&&(this.main.materialsTransport=e),this}getMaterialsTransport(){return this.main.materialsTransport}setMesh(e,t){return this.main.meshName=e.name,super.setGeometry(e.geometry,t),this}package(e){return super.package(e),null!==this.main.materialsTransport&&this.main.materialsTransport.package(e),this}reconstruct(e){return super.reconstruct(e),this}}class b{static serializePrototype(e,t,s,i){let r,n=[],a="";i?(a=e.toString()+"\n\n",r=t):r=e;for(let e in r){let t=r[e],s=t.toString();"function"==typeof t&&n.push("\t"+e+": "+s+",\n\n")}a+=s+(i?".prototype":"")+" = {\n\n";for(let e=0;e<n.length;e++)a+=n[e];return a+="\n}\n;",a}static serializeClass(e){return e.toString()+"\n\n"}}class y{static applyProperties(e,t,s){if(null==e||null==t)return;let i,r,n;for(i in t)r="set"+i.substring(0,1).toLocaleUpperCase()+i.substring(1),n=t[i],"function"==typeof e[r]?e[r](n):(e.hasOwnProperty(i)||s)&&(e[i]=n)}}class T{constructor(e){if(this.materials={},e){const e=new a({color:14479871});e.name="defaultMaterial";const t=new a({color:14479871});t.name="defaultVertexColorMaterial",t.vertexColors=o;const s=new l;s.name="defaultLineMaterial";const i=new u({size:.1});i.name="defaultPointMaterial",this.materials[e.name]=e,this.materials[t.name]=t,this.materials[s.name]=s,this.materials[i.name]=i}}addMaterials(e,t){if(null==e&&(e={}),Object.keys(e).length>0){let s;for(const i in e)s=e[i],h.addMaterial(this.materials,s,i,!0===t)}}getMaterials(){return this.materials}getMaterial(e){return this.materials[e]}clearMaterials(){this.materials={}}}class k{static comRouting(e,t,s,i,r){let n=t.data;"init"===n.cmd?null!=s?s[i](e,n.workerId,n.config):i(e,n.workerId,n.config):"execute"===n.cmd&&(null!=s?s[r](e,n.workerId,n.config):r(e,n.workerId,n.config))}}class w{constructor(e){this.taskTypes=new Map,this.verbose=!1,this.maxParallelExecutions=e||4,this.actualExecutionCount=0,this.storedExecutions=[],this.teardown=!1}setVerbose(e){return this.verbose=e,this}setMaxParallelExecutions(e){return this.maxParallelExecutions=e,this}getMaxParallelExecutions(){return this.maxParallelExecutions}supportsTaskType(e){return this.taskTypes.has(e)}registerTaskType(e,t,s,i,r,n){let a=!this.supportsTaskType(e);if(a){let a=new M(e,this.maxParallelExecutions,r,this.verbose);a.setFunctions(t,s,i),a.setDependencyDescriptions(n),this.taskTypes.set(e,a)}return a}registerTaskTypeModule(e,t){let s=!this.supportsTaskType(e);if(s){let s=new M(e,this.maxParallelExecutions,!1,this.verbose);s.setWorkerModule(t),this.taskTypes.set(e,s)}return s}async initTaskType(e,t,s){let i=this.taskTypes.get(e);if(i)if(i.status.initStarted)for(;!i.status.initComplete;)await this._wait(10);else i.status.initStarted=!0,i.isWorkerModule()?await i.createWorkerModules().then((()=>i.initWorkers(t,s))).then((()=>i.status.initComplete=!0)).catch((e=>console.error(e))):await i.loadDependencies().then((()=>i.createWorkers())).then((()=>i.initWorkers(t,s))).then((()=>i.status.initComplete=!0)).catch((e=>console.error(e)))}async _wait(e){return new Promise((t=>{setTimeout(t,e)}))}async enqueueForExecution(e,t,s,i){return new Promise(((r,n)=>{this.storedExecutions.push(new x(e,t,s,r,n,i)),this._depleteExecutions()}))}_depleteExecutions(){let e=0;for(;this.actualExecutionCount<this.maxParallelExecutions&&e<this.storedExecutions.length;){let t=this.storedExecutions[e],s=this.taskTypes.get(t.taskType),i=s.getAvailableTask();if(i){this.storedExecutions.splice(e,1),this.actualExecutionCount++,new Promise(((e,s)=>{i.onmessage=s=>{"assetAvailable"===s.data.cmd?t.assetAvailableFunction instanceof Function&&t.assetAvailableFunction(s.data):e(s)},i.onerror=s,i.postMessage({cmd:"execute",workerId:i.getId(),config:t.config},t.transferables)})).then((e=>{s.returnAvailableTask(i),t.resolve(e.data),this.actualExecutionCount--,this._depleteExecutions()})).catch((e=>{t.reject("Execution error: "+e)}))}else e++}}dispose(){this.teardown=!0;for(let e of this.taskTypes.values())e.dispose();return this}}class M{constructor(e,t,s,i){this.taskType=e,this.fallback=s,this.verbose=!0===i,this.initialised=!1,this.functions={init:null,execute:null,comRouting:null,dependencies:{descriptions:[],code:[]},workerModuleUrl:null},this.workers={code:[],instances:new Array(t),available:[]},this.status={initStarted:!1,initComplete:!1}}getTaskType(){return this.taskType}setFunctions(e,t,s){this.functions.init=e,this.functions.execute=t,this.functions.comRouting=s,void 0!==this.functions.comRouting&&null!==this.functions.comRouting||(this.functions.comRouting=k.comRouting),this._addWorkerCode("init",this.functions.init.toString()),this._addWorkerCode("execute",this.functions.execute.toString()),this._addWorkerCode("comRouting",this.functions.comRouting.toString()),this.workers.code.push('self.addEventListener( "message", message => comRouting( self, message, null, init, execute ), false );')}_addWorkerCode(e,t){t.startsWith("function")?this.workers.code.push("const "+e+" = "+t+";\n\n"):this.workers.code.push("function "+t+";\n\n")}setDependencyDescriptions(e){e&&e.forEach((e=>{this.functions.dependencies.descriptions.push(e)}))}setWorkerModule(e){this.functions.workerModuleUrl=new URL(e,window.location.href)}isWorkerModule(){return null!==this.functions.workerModuleUrl}async loadDependencies(){let e=[],t=new c;t.setResponseType("arraybuffer");for(let s of this.functions.dependencies.descriptions){if(s.url){let i=new URL(s.url,window.location.href);e.push(t.loadAsync(i.href,(e=>{this.verbose&&console.log(e)})))}s.code&&e.push(new Promise((e=>e(s.code))))}this.verbose&&console.log("Task: "+this.getTaskType()+": Waiting for completion of loading of all dependencies."),this.functions.dependencies.code=await Promise.all(e)}async createWorkers(){let e;if(this.fallback)for(let t=0;t<this.workers.instances.length;t++)e=new E(t,this.functions.init,this.functions.execute),this.workers.instances[t]=e;else{let t=new Blob(this.functions.dependencies.code.concat(this.workers.code),{type:"application/javascript"}),s=window.URL.createObjectURL(t);for(let t=0;t<this.workers.instances.length;t++)e=new A(t,s),this.workers.instances[t]=e}}async createWorkerModules(){for(let e,t=0;t<this.workers.instances.length;t++)e=new A(t,this.functions.workerModuleUrl.href,{type:"module"}),this.workers.instances[t]=e}async initWorkers(e,t){let s=[];for(let i of this.workers.instances){let r=new Promise(((s,r)=>{let n;if(i.onmessage=e=>{this.verbose&&console.log("Init Complete: "+e.data.id),s(e)},i.onerror=r,t){n=[];for(let e=0;e<t.length;e++)n.push(t[e].slice(0))}i.postMessage({cmd:"init",workerId:i.getId(),config:e},n)}));s.push(r)}this.verbose&&console.log("Task: "+this.getTaskType()+": Waiting for completion of initialization of all workers."),await Promise.all(s),this.workers.available=this.workers.instances}getAvailableTask(){let e;return this.hasTask()&&(e=this.workers.available.shift()),e}hasTask(){return this.workers.available.length>0}returnAvailableTask(e){this.workers.available.push(e)}dispose(){for(let e of this.workers.instances)e.terminate()}}class x{constructor(e,t,s,i,r,n){this.taskType=e,this.config=t,this.assetAvailableFunction=s,this.resolve=i,this.reject=r,this.transferables=n}}class A extends Worker{constructor(e,t,s){super(t,s),this.id=e}getId(){return this.id}}class E{constructor(e,t,s){this.id=e,this.functions={init:t,execute:s}}getId(){return this.id}postMessage(e,t){let s=this,i={postMessage:function(e){s.onmessage({data:e})}};k.comRouting(i,{data:e},null,s.functions.init,s.functions.execute)}terminate(){}}export{f as DataTransport,m as DeUglify,p as GeometryTransport,T as MaterialStore,h as MaterialUtils,d as MaterialsTransport,g as MeshTransport,y as ObjectManipulator,b as ObjectUtils,w as WorkerTaskManager,k as WorkerTaskManagerDefaultRouting};
